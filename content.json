{"pages":[{"title":"[Jekyll] Jekyll로 깃허브 블로그 만들기","text":"","link":"/2019-12-24-jekyll-1.html"},{"title":"","text":"About Kungbi ## **Intro.** 안녕하세요, 저는 신웅비입니다. 항상 호기심이 많고 컴퓨터를 좋아하는 초보 개발자 입니다. 어렸을 때부터 컴퓨터에 관심이 많아 직접 개발해보고 기술들을 공부하면서 개발자가 되어 사람들에게 좋은 영향을 줄 수 있는 소프트웨어를 개발하고자 개발자가 되었습니다. 메인포지션 할꺼없이 웹, 모바일, 인공지능, 보안 등 여러 분야들에 대해서 가리지않고 공부중입니다.(학생이라 시간이 많습니다.) 사람을 만나는 것을 좋아하고, 새롭게 알게되는 사람 또한 좋아합니다. 여러 사람들과 함께 IT이야기나 재미있는 이야기를 나누는 것을 좋아합니다. (근데 요즘 플스에 빠지게 되면서 집에서 잘 안나가고 있긴 하다.) 살짝 늦게 개발 블로그를 시작하긴 했지만, 지금이라도 제가 공부한 것들이라 저의 일상을 기록하면서 추억과 경험을 남기고 한편으로 반성을 하고자 시작했습니다. 개발 프로젝트 ViDEEP: 영상 유해도 분석기2018.05.07 ~ 2018.07.08 딥러닝 기법을 이용한 가짜뉴스 탐지2018.05.07 ~ 2018.07.08 다이어리 톡: 일기와 메신저를 더하다2017.01.02 ~ 2017.05.28 태릉고등학교 공식 어플리케이션2017.06.01 ~ 2017.07.02 Tip Toe: 위치기반 음악 추천 스트리밍 서비스2017.02.25 ~ 2017.02.26 학교 도움이 어플리케이션2015.08.02 ~ 2015.09.03 C언어기반 슈팅 게임2015.06.01 ~ 2015.07.02 수상 2018년 춘계 학술대회 - 최우수 논문상(1위) 2018년 올림피아드 공모전 - 은상 2017년 예술해커톤 : 예술 데이터 - 최우수상(1위) 약력 한국외국어대학교 글로벌캠퍼스 재학중 원묵초/원묵중/태릉고 졸업 서울 출생","link":"/about/index.html"}],"posts":[{"title":"백준 10837번 문제","text":". 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;int K, C, M, N, m, n;int check(){ if(m != M || n != N) return 0; else return 1;}int max(int a, int b){ if(a &gt; b) return a; else return b;}int main() { scanf(\"%d\", &amp;K); scanf(\"%d\", &amp;C); for(int c = 0; c &lt; C; c++){ scanf(\"%d %d\", &amp;M, &amp;N); m = 0; n = 0; for(int k = 1; k &lt; K+1; k++){ if(m == max(M, N) || n == max(M, N)) break; if(m+1 &lt;= M) m++; if(m+K-k &lt; n) { break; } if(n+1 &lt;= N) n++; if(n+K-k &lt; m) { if(!check()) { break; } } } if(!check()) { printf(\"0\\n\"); }else printf(\"1\\n\"); } return 0;}","link":"/2020/02/11/Algorithm/baekjoon-10837/"},{"title":"백준 10840번 문제","text":". 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;vector&lt;int&gt; Prime;const int mod = 524287;vector&lt;pair&lt;int, int&gt;&gt; Hash[mod];int x, y, len, Nlen, Mlen, now, result = 0;bool isPrime(int num){ for(int i = 2; i &lt;= sqrt(num); i++){ if(num % i == 0) return false; } return true;}void getPrime(){ int count = 0; int num = 2; while(true){ if(isPrime(num)){ Prime.push_back(num); ++count; } ++num; if(count == 2000) {// cout &lt;&lt; num; break; } }}void solve(string &amp;N, string &amp;M){ Nlen = N.length(); Mlen = M.length(); for(int i = 0; i &lt; Nlen; i++){ x = y = 1; for(int k = i; k &lt; Nlen; k++){ len = k-i+1; now = N[k] - 'a'; x = (x*Prime[now]) % mod; y = (y*Prime[now+26]) % mod; Hash[x].push_back({y, len}); } } for(int i = 0; i &lt; Mlen; i++){ x = y = 1; for(int k = i; k &lt; Mlen; k++){ len = k-i+1; now = M[k] - 'a'; x = (x*Prime[now]) % mod; y = (y*Prime[now+26]) % mod; bool flag = false; for(int j = 0; j &lt; Hash[x].size(); j++){ if(Hash[x][j] == make_pair(y, len)) { flag = true; break; } } if(flag){ result = max(len, result); } } } cout &lt;&lt; result;}int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); getPrime(); string N, M; cin &gt;&gt; N &gt;&gt; M; solve(N, M); return 0;}","link":"/2020/02/11/Algorithm/baekjoon-10840/"},{"title":"[알고리즘] Intro","text":"고등학교때 잠깐 알고리즘 공부를 했었는데, 그땐 별로 재미없기도 하고 할 이유가 별로 없어서 바로 그만뒀던 것 같다. 이제 곧 대학 수업에 알고리즘도 들어가고 코테준비도 하고 그러려면 지금부터 알고리즘을 공부해야할 것 같다. 그래서 이렇게 카테고리를 만들어서 공부를 시작해보려고 합니다.","link":"/2020/01/20/Algorithm/new-category-algorithm/"},{"title":"[부스트코스] 브라우저의 작동 방식","text":"오늘은 웹브라우저가 어떻게 렌더링과정을 거쳐서 화면에 보이게 되는지에 대해서 강의를 듣고 공부를 했다. 웹브라우저가 서버로부터 리소스를 받으면 어떤 과정으로 처리하고, 화면에 보이기 까지 과정을 포스팅 하려고 한다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. 브라우저의 주요기능 서버와의 통신을 담당한다. 서버로 부터 받은 리소스(HTML, PDF, 이미지, 동영상 등)을 화면에 표시될 수 있도록 한다. HTML, CSS, JavaScript 를 해석해서 화면에 그려준다. 브라우저의 대표적인 기능은 화면에 받은 리소스들을 해석해 표현하는 것이라 볼 수 있다. 그렇다면 이를 어떤 방식으로 처리하는지 알아보자. 일단 브라우저의 구조부터 확인하자. 브라우저 기본 구조브라우저는 여러 많은 종류가 있다. Chrome, Explorer, Firefox 등 말이다. 그런데 기본적인 구조는 동일하다. 다음은 브라우저의 기본 구조이다. 사용자 인터페이스주소 표시줄, 이전/다음 버튼, 북마크 등 사용자가 직접 볼 수 있고, 활용할 수 있는 서비스들. 브라우저 엔진사용자 인터페이스와 렌더링 엔진 사이의 동작 제어. 렌더링 엔진받은 리소스들을 표시, HTML CSS JavaScript를 해석해 화면에 그려준다. 통신HTTP 요청과 같은 네트워크 통신에 사용된다. 자바스크립트 해석기자바스크립트 코드를 해석한다. UI 백엔드플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용. 자료 저장소쿠키와 같이 계속 저장해야하는 데이터를 저장하는 곳. 렌더링 엔진이번 포스팅에서 주요하게 봐야할 주제를 렌더링 이다. 렌더링을 하기 위해선 렌더링 엔진을 이해하는 것이 중요하다. 렌더링 엔진은 HTML 및 XML 문서와 이미지를 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF와 같은 다른 유형도 표시할 수 있다. 렌더링 엔진은 여러 종류가 있는데, 게코(Gecko), 블링크(Blink), 웹키트(Webkit) 등 여러개가 존재한다. 동작 과정 DOM 이란 Document Object Model 이다. HTML를 하나의 객체 트리로 만들어, 프로그래밍 언어(JavaScript)가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다. DOM은 HTML을 토대로 객체로 만들어 트리형식으로 DOM 트리 를 구축하게 된다. 그리고 외부 CSS파일과 함께 포함된 스타일 요소들을 파싱한다. 스타일 정보와 HTML 표시 규칙은 렌더 트리 라는 또하나의 트리를 생성한다. 렌더 트리 생성이 끝나면 배치가 시작되는데 이것은 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다. 마지막으로 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어 내는 그리기 과정 이다. ❖ 이 과정은 1, 2, 3, 4 순서대로 동기적으로 이루어지는 것이 아니라 모든 HTML이을 파싱할할때 까지 기다리지 않고 파싱이 되는대로 배치 -&gt; 그리기를 반복한다고 한다. 웹사이트에 들어가게 되면 한번에 뜨지않고 부분부분 나오는 이유. 동작 과정 예 파싱과 DOM 트리 구축파싱은 렌더링에서 매우 중요한 개념이다. 문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미한다. 123456&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;div&gt;&lt;img src=\"example.png\" /&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 다음과 같이 html 태그 아래 body태그 아래 p태그 와 div태그가 있고 p 태그 아래에는 텍스트가 div태그 아래에는 img 태그가 존재한다. 이를 파싱해 트리형태로 DOM을 구현한다.","link":"/2020/01/30/Booster/how-browser-work/"},{"title":"[부스트코스] HTTP 프로토콜이란?","text":"웹 브라우저와 웹 서버 간에 서로 통신하기 위해서는 일종의 규약이 필요하다. 이때 필요한 규약이 HTTP이다. 이번 포스팅에선 HTTP에 대하여 글을 써보려고 한다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. HTTP(Hypertext Transfer Protocol) 이란?HTTP는 인터넷에서 데이터를 주고받기 위한 프로토콜이다. 프로토콜을 쉽게 말해서 규칙이라 보면 된다. 로컬에서만 동작하는(인터넷을 사용하지 않는) 소프트웨어가 아닌, 서버와 상호작용하는 소프트웨어를 개발한다면 HTTP Protocol에 대해서 기본적인 개념을 알아야 한다. HTTP는 1989년 **팀 버너스리(Tim Berners-Lee)** 에 의해 처음 설계되어 인터넷을 통한 **World Wide Web(WWW)**을 기반으로 전 세계적인 정보공유를 이루는데 큰 역할을 했다. HTTP 말 그대로 hyper 초월의 뜻으로 hypertext는 그저 텍스트가 아닌 그 이상을 뛰어넘어 이미지, 동영상, 오디오 등을 표현할 수 있다는 의미로 해석하면 된다. HTTP는 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 한 지점에서 다른 지점으로 요청과 응답을 전송한다. HTTP 작동 방식 HTTP는 기본적으로 **Request(요청)**과 **Response(응답)** 으로 나뉜다. **클라이언트(브라우저)**가 서버에 접속하면 Request를 하게 되고 **서버**에선 Request에 따라서 맞는 Response를 하게 된다. 만약 http://naver.com 에 접속하게 된다면, 네이버 서버는 네이버 홈페이지를 응답하게 되고 https://news.naver.com 에 접속하면 네이버는 네이버 뉴스 페이지를 응답하게 된다. HTTP 특징 HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.따라서 서버 간의 최대 연결 수보다 훨씬 많은 요청과 응답을 처리할 수 있다.그러나 연결을 끊어버리기 때문에, 클라이언트의 이전 상황을 알 수가 없다. 이러한 단점을 해결하기 위해 Cookie와 Seesion 등장하게 된다. HTTP는 연결을 유지하지 않는 프로토콜이기 떄문에 요청/응답(request/response) 방식으로 동작한다. URL(Uniform Resorce Locator)1http://kungbi.github.io URL은 인터넷 상의 자원(컴퓨터)가 어디에 있는지를 알려주기 위한 규약이다. 집 주소(도로명 주소)와 똑같은 개념이다. URL에 접속하기 위해선 해당 URL에 맞는 프로토콜을 알아야 하고, 그와 동일한 프로토콜로 접속해야 한다. HTTP Header **HTTP Header**은 웹브라우저가 HTTP프로토콜을 이용해 요청 정보를 웹 서버로 전송할 때 HTTP 요청 헤더에 **부가적인 정보**를 담아 전송한다. 대표적인 몇가지를 소개하려고 한다. 요청 URL 요청을 하는 자원의 URL 의미한다. 요청 메서드 GET : 정보를 요청하기 위해 사용. POST: 정보를 입력하기 위해 사용. PUT : 정보를 수정하기 위해 사용. DELETE : 정보를 삭제하기 위해 사용. … 쿠키 HTTP의 비연결성의 단점을 해결하기 위해 사용자의 상태 정보를 저장하는 것을 쿠키라 한다. 요청을 할시에 쿠키를 같이 전송하여 인증을 시행한다. ex) 자동 로그인, 로그인 상태 유지 HTTPS? **HTTPS**는 **HTTP**와 같은 통신 프로토콜이다. 사용방식 또한 HTTP와 거의 비슷하다. HTTP와 HTTPS와의 차이점은 HTTP의 취약점을 보완한 것에 있다. HTTP는 서버와 주고받는 패킷이 암호화 처리가 되어 있지 않아 만약 중간에 패킷을 가로챈다면 보안상 치명적인 결과를 가져올 수 있다. 그래서 HTTPS는 HTTP의 취약점을 보완하기 위해 주고받는 모든 메시지를 암호화한다. 즉, 중간에 패킷을 가로챈다고 해도 암호화된 내용이 노출되기 떄문에 보안상 안전하고, 공유된 대칭키를 모르는 상황에서 암호화를 푼다는 것은 모든 경우의 키를 대입해야한다는 것이다. 만약 1024 비트(보통은 128비트 암호화)의 암호화라면, 평균적으로 2의 512승을 대입해야하며, 이것은2475880078570760000000000000.00이라는 수를 대입해야 한다는 뜻과 같다고 한다.","link":"/2020/01/29/Booster/http-protocol/"},{"title":"부스트코스 서포터즈 BOOSTER","text":"edwith는 네이버(NAVER)와 커넥트재단(CONNECT)이 비영리로 운영중인 MOOC사이트이다. MOOC은 온라인 공개수업(Massive Open Online Course)을 의미한다. 그래서 이번에 부스트코스 서포터즈 BOOSTER 2기를 모집하길래 어떤 활동인지 알아보았다. 생각보다 체계적인 운영 방식으로 되어있었다. 지원하기 전 강의를 몇개 구경했는데 강의 품질도 좋았다. 제일 좋았던 부분은 프로젝트 미션이 있다는 것이다. 사실 개념만 공부만 하다보면 피곤하기도하고 재미도 없다. 근데 부스트코스는 프로젝트 미션과 함께 실제 현업 전문가가 코드리뷰를 해서 피드백을 받을 수 있다. 게다가 모두 수료하면 기업 연계 기회도 준다고 한다(사실 네이버가 하는거면 다 좋아보인다.)). 다른 신기한 점은, 부스트코스에서 블로그 운영, 포스팅을 유도한다. 개발자라면 하나씩 있어야하는 개발 블로그, 보통의 컴공 대학생은 개발 블로그를 운영하지 않는다. 그래서 부스트코스는 대학생들에게 정말 도움되는 활동이 아닌가 싶다. 나도 부스트코스를 하면서 글을 주기적으로 올리려고한다. 할튼간에 부스트코스 서포터즈 BOOSTER 2기에 합격했기 때문에, 앞으로 강의를 들으면서 배운점 공유하고싶은 부분은 글을 쓰려고한다.","link":"/2020/01/26/Booster/new-category-boostcourse/"},{"title":"[C++] STL 이란","text":"C++ 공부와 알고리즘 공부 차원에서 STL에 대해서 알아보았다. STL이란 표준 C++ 라이브러리(Standard Template Library) 프로그램에 필요한 자료구조와 알고리즘을 템플릿으로 제공하는 라이브러리 STL 구성 요소ContainerSTL 데이터를 보관하기 위한 다양한 컨테이너를 제공한다. 컨테이너는 데이터를 저장하는 객체이다. Sequence containers array vector deque forward_list list Associative containers set multiset map multimap Unordered associative containers unordered_set unordered_multiset unordered_map unordered_multimap Container adaptors stack queue priority_queue Iterator포인터처럼 컨테이너 원소를 가리키고, 가리키는 원소의 다음 원소를 가리길 수 있는 기능이다. 데이터들을 순회할 수 있는 반복자이다. Algorithm정렬, 삭제, 검색, 연산 등을 해결하는 알고리즘 제공. FunctorSTL에는 함수 호출 연산자를 오버로드하는 클래스가 포함되어 있다. 이러한 클래스의 인스턴스를 함수 객체 또는 펑터라고한다. 펑터를 사용하면 매개 변수를 통해 관련 기능의 작업을 사용자 정의 할 수 있다.","link":"/2020/02/04/C++/what-is-stl/"},{"title":"Next.js - Link API 라우팅","text":"Next.js의 핵심 기능 중 하나인 Link API 라우팅 에 대해서 알아보려고 한다. Link API는 손쉽게 라우팅을 할 수 있게 해주는 API이다. Next.js의 핵심 기능 중 하나이다. 우선 Link API를 사용하려면 라이브러리를 import 해주어야 한다. 1import Link from 'next/link'; pages/index.js 로 가서 코드를 수정해 보자. 12345678910111213141516import Link from 'next/link';const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;Link href='/about'&gt; &lt;a&gt;Link API - About&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt;);export default Index; 그리고 localhost:3000 으로 들어가 Link API - About 를 클릭해보면 about 페이지로 넘어간다. 그렇다면 우리가 평소에 사용했었던 &lt;a&gt; 태그를 사용해보자. 12345678910111213141516171819import Link from 'next/link';const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;Link href='/about'&gt; &lt;a&gt;Link API - About&lt;/a&gt; &lt;/Link&gt; &lt;br/&gt; &lt;a href='/about'&gt;A tag - About&lt;/a&gt; &lt;/div&gt;);export default Index; 둘의 차이를 확인해보자. 다른 것이 보일 것이다. &lt;a&gt;태그를 활용한 페이지 이동은 새로고침을 하여서 다시 SSR을 하게 된다. 반면 Link API를 활용한 페이지 이동은 새로고침을 하지 않고 CSR을 하게 된다.","link":"/2020/01/03/Next.js/Next.js%20Link%20API/"},{"title":"Next.js - Component 생성","text":"React에서 component를 생성해서 여러가지 방법으로 재사용하고 편리하게 화면을 구성할 수 있는 요소이다. Next.js에서 component를 어떻게 생성하는지 알아보았다. 컴포넌트 디렉토리Next.js에서 컴포넌트를 생성하기 위해선 components 디렉토리가 필요하다. 최상위 디렉토리에서 components 디렉토리를 생성하자. components디렉토리에 컴포넌트를 생성하지 않으면 오류가 발생한다. 헤더 컴포넌트 생성components/Header.js 를 생성한다. 그리고 다름 코드를 작성하였다. 123456789101112131415161718192021222324252627import Link from 'next/link';const LinkStyle = { marginRight: '1rem', fontSize: '1.5rem'};const HeaderStyle = { border: '0.5rem dashed pink', borderRadius: '10px', margin: '1rem', padding: '1rem'};const Header = () =&gt; ( &lt;div style={HeaderStyle}&gt; &lt;Link href=\"/\"&gt; &lt;a style={LinkStyle}&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;Link href=\"/about\"&gt; &lt;a style={LinkStyle}&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt;);export default Header; 컴포넌트 importpages/index.js 와 pages/about.js 에서 components/Header.js 를 사용해보자. 12345678910111213141516171819202122import Link from 'next/link';import Header from '../components/Header';const Index = () =&gt; ( &lt;div&gt; &lt;Header/&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;Link href='/about'&gt; &lt;a&gt;Link API - About&lt;/a&gt; &lt;/Link&gt; &lt;br/&gt; &lt;a href='/about'&gt;A tag - About&lt;/a&gt; &lt;/div&gt;);export default Index; 12345678910import Header from \"../components/Header\";const About = () =&gt; ( &lt;div&gt; &lt;Header/&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/div&gt;);export default About; 결과 레이아웃 컴포넌트레아아웃 컴포넌트는 페이지를 구성한는 여러가지 컴포넌트를 사용해 웹사이트 전체적인 레이아웃을 구성한다. 이점은 여러페이지 마다 많은 컴포넌트를 사용하지 않고 레이아웃 컴포넌트 하나만 사용하면 되고 유지보수 측면으로도 간편하기 때문이다. 그러면 components/BaseLayout.js 를 생성하여 다음 코드를 작성하자. 12345678910import Header from \"./Header\";const BaseLayout = (props) =&gt; ( &lt;div&gt; &lt;Header/&gt; {props.children} &lt;/div&gt;);export default BaseLayout 그리고 index.js 와 about.js 도 다음과 같이 수정하자. 123456789101112131415161718192021import Link from 'next/link';import BaseLayout from '../components/BaseLayout'const Index = () =&gt; ( &lt;BaseLayout&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;Link href='/about'&gt; &lt;a&gt;Link API - About&lt;/a&gt; &lt;/Link&gt; &lt;br/&gt; &lt;a href='/about'&gt;A tag - About&lt;/a&gt; &lt;/BaseLayout&gt;);export default Index; 123456789import BaseLayout from \"../components/BaseLayout\";const About = () =&gt; ( &lt;BaseLayout&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/BaseLayout&gt;);export default About; 결과결과는 이전과 같을 것이다. 그러나 레이아웃 컴포넌트를 통해 유지보수가 더 간편해지고(Header.js를 수정하면 모든 페이지의 Header를 변경할 수 있다.), 많은 페이지 개발이 필요하다면 BaseLayout.js를 통해 간편하게 개발할 수 있을 것이다.","link":"/2020/01/09/Next.js/next.js_make_component/"},{"title":"Next.js로 프로젝트 생성하기","text":"이번 포스팅은 Next.js로 프로젝트를 생성하는 것에 대해서 작성해보려고 한다. 설치12345$ mkdir todo-list$ cd todo-list$ yarn init -y$ yarn add react react-dom next$ mkdir pages 그리고 “package.json” 파일을 수정하자. 다음과 같이 npm 스크립트를 추가하면 된다. 12345\"scripts\": { \"dev\": \"next\", \"build\", \"next build\", \"start\", \"next start\"}, 다음 명령어로 개발 서버를 실행할 수 있다. $ npm run dev 다음과 같이 출력되면 서버가 정상적으로 실행된 것이다. http://localhost:3000 으로 접속할 수 있다. 404 페이지그러면 다음과 같이 보이게 된다. 404에러가 출력되면서 페이지가 없다고 한다. 그러면 페이지를 만들어보자. 페이지 생성index.js 파일 생성pages폴더에 index.js 파일을 생성해서 다음과 같이 수정해 보자. 123456789const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt; Hello, World! &lt;/h1&gt; &lt;/div&gt;);export default Index; 주의 사항next.js를 사용하면서 꼭 지켜야할 규칙들이 있다. pages 폴더가 꼭 필요하다. 그리고 라우팅 URL과 컴포넌트의 이름이 같아야 한다. 예를 들어서 url이 /about이라면 pages/about.js파일을 만들어야 한다.","link":"/2020/01/03/Next.js/make_project_with_nex.js/"},{"title":"Next.js란?","text":"학교 프로젝트를 하다가 웹사이트를 만들어야할 필요가 있어서 Next.js라는 친구를 공부해봤다. 괜찮았고, 계속 공부해볼만한 가치가 있었다. Next.jsReact 프로젝트를 시작할 때 많은 사람들이 Create React App을 사용했을 것이다. CRA는 기본적인 React 프로젝트를 생성하기에 좋은 툴이다. 그러나 CRA는 서버에서 페이지를 렌더링 하지 않는다. 오직 클라이언트 사이드 렌더링만 지원한다. 그리고 러닝 커브가 높다. 클라이언트 사이드 라우팅과 페이지 레이아웃 등을 공부해야 하기 때문이다. 이를 해결하고 간편하게 React 프로젝트를 생성할 수 있게 도와주는 Next.js를 소개한다. PHP로 만든 웹페이지를 생각해보자. 라우팅에 대해서 전혀 걱정하지 않았을 것이다. 그러나 React는 따로 라우팅을 해주어야 한다. 이를 대신 처리해 주는 것이 React.js 전용 프레임 워크인 Next.js이다. Next.js의 장점 기본적으로 서버 사이드 렌더링을 해준다. 그래서 클라이언트의 초기 렌더링 속도를 향상 시켜줌. 빠른 속도를 위해 code-splitting을 지원한다. 클라이언트 사이드 라우팅도 지원한다. Next.js 동작 방식SSR은 서버에서 렌더링 하는 것이다. PHP, JSP가 대표적인 SSR 프레임 워크이다. 미리 html을 작성하여 어떤 유저가 url에 접근하면 그 url에 맞는 html을 전송하는 방식이다. next.js에서의 SSR도 다르지 않다. 서버(node.js)를 실행하고 사용자가 요청하면 html을 생성하여 사용자에게 전송한다. 다른 점은 모든 요청에 대해서 SSR을 하는 것이 아니라, 초기 렌더링만 해당한다. 그 이후로는 next/router를 통해 렌더링 한다. 이러한 방식으로 SPA의 단점인 초기 렌더링 시간을 줄일 수 있다. CSR은 Client Side Rendering이다. CSR은 HTML, CSS, JS를 받고 그 이후에 렌더링을 시작한다. Next.js는 다음과 같은 순서로 실행 된다. 유저가 페이지에 접속한다. 실행되고 있는 node 서버가 요청을 받고 서버 렌더링을 한다. 만들어진 HTML을 전송한다. 사용자가 다른 경로(링크)를 클릭하면, 해당 URL로 라우팅한다. 그리고 해당 페이지 코드를 렌더링 한다.","link":"/2020/01/03/Next.js/what_is_Next.js/"},{"title":"Next.js - 게시판 만들기","text":"이전 포스팅에선 Link API를 사용해서 다른 페이지로 넘어가는 것을 구현했다. 이번 포스팅에서는 간단한 게시판(DB사용 X)을 만들어보려고 한다. 게시물 목록 구현우선 게시물 페이지로 넘어가기 위한 게시물 목록을 만들어보자. components/PostLink.js 파일을 생성하여 다음 코드를 작성하자. 123456789import Link from 'next/link';export default (props) =&gt; ( &lt;li&gt; &lt;Link href={`/post?id=${props.id}`}&gt; &lt;a style={{fontSize: '1.5rem'}}&gt;{props.title}&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;); posts/index.js 를 다음과 같이 수정했다. 12345678910111213141516171819202122232425262728293031323334import BaseLayout from '../components/BaseLayout';import PostLink from '../components/PostLink';const posts = [ {id:1, title: \"Post Title #1\", content: \"#1 content\"}, {id:2, title: \"Post Title #2\", content: \"#2 content\"}, {id:3, title: \"Post Title #3\", content: \"#3 content\"}, {id:4, title: \"Post Title #4\", content: \"#4 content\"}, {id:5, title: \"Post Title #5\", content: \"#5 content\"}, {id:6, title: \"Post Title #6\", content: \"#6 content\"}, {id:7, title: \"Post Title #7\", content: \"#7 content\"}, {id:8, title: \"Post Title #8\", content: \"#8 content\"}, {id:9, title: \"Post Title #9\", content: \"#9 content\"}];const PostList = () =&gt; ( &lt;&gt; {posts.map((data, index) =&gt; { return &lt;PostLink id={data.id} title={data.title} key={index}/&gt; })} &lt;/&gt;);const Index = () =&gt; ( &lt;BaseLayout&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;PostList/&gt; &lt;/BaseLayout&gt;);export default Index; posts 변수는 게시물 목록 더미데이터 이다. 그리고 map 함수로 posts 데이터들을 사용해 &lt;PostLink&gt; 컴포넌트를 생성했다. 그러면 다음과 같이 화면에 출력된다. 게시물 세부 내용 확인 페이지이번엔 각 게시물을 볼 수 있도록 게시물을 보는 페이지를 만들어보자. pages/post.js 파일을 생성해서 다음의 코드를 작성했다. 123456789101112131415161718192021222324252627282930313233343536373839import BaseLayout from \"../components/BaseLayout\";import {useRouter} from 'next/router';const posts = [ {id:1, title: \"Post Title #1\", content: \"#1 content\"}, {id:2, title: \"Post Title #2\", content: \"#2 content\"}, {id:3, title: \"Post Title #3\", content: \"#3 content\"}, {id:4, title: \"Post Title #4\", content: \"#4 content\"}, {id:5, title: \"Post Title #5\", content: \"#5 content\"}, {id:6, title: \"Post Title #6\", content: \"#6 content\"}, {id:7, title: \"Post Title #7\", content: \"#7 content\"}, {id:8, title: \"Post Title #8\", content: \"#8 content\"}, {id:9, title: \"Post Title #9\", content: \"#9 content\"}];const Content = () =&gt; { const router = useRouter(); const post = posts[router.query.id -1]; const title = post.title; const content = post.content; return( &lt;&gt; &lt;h1&gt;{title}&lt;/h1&gt; &lt;p&gt;{content}&lt;/p&gt; &lt;/&gt; );}const Post = (props) =&gt; { return( &lt;BaseLayout&gt; &lt;Content/&gt; &lt;/BaseLayout&gt; );};export default Post; next/router 로 현재 파라미터를 받아와서 해당 데이터를 posts json변수에서 받아온다. 그리고 title과 content를 추출해 화면에 출력했다.","link":"/2020/01/12/Next.js/next-js-make-board_1/"},{"title":"Fetch API 사용하기","text":"fetch()는 네트워크 요청을 쉽게 활용할 수 있게 만들어준다. api를 가져올 때 예전에는 XMLHttpRequest을 사용했다. 이 포스팅에서는 보다 편리하게 개발할 수 있게 도와주는 fetch를 사용하여 쉽게 데이터를 가져오는 방법을 포스팅 하려고 한다. Fetch API 사용법일반적인 Fetch API 문법#1: 데이터만 가져올 때1fetch(url) #2: 데이터를 받아와 이후에 처리할 내용이 있다면123fetch(url).then(function(response) { // Code ...}); Fetch API 옵션 및 파라미터12345678fetch(url, { method: 'GET', headers: { 'Content-Type': 'application/json' }}).then(function(response) { // Code ...}) api를 통해 연습해보기랜덤으로 유저 정보를 생성해서 정보를 제공하는 API가 있다. 이 API를 통해서 fetch를 연습해보자. 랜덤 유저 생성기랜덤유저생성기는 자동으로 유저 정보를 생성해준다. 10명의 정보를 가져오려 한다면 파라미터로 ?result=10이라고 붙여주면 된다.그러면 fetch로 랜덤 유저 생성기 API를 사용해 결과를 콘솔 로그창에 출력해보자. Chrome의 개발자모드로 들어가 Console에서 로그를 확인 할 수 있다. 위의 코드를 실행하면 “프로미스”라는 값을 받게 된다. 프로미스는 자바스크립트의 비동기 처리에 활용되는 객체 이다. 동기라는 것은 프로그램이 끝날 때까지 다른 일은 하지 않는 것이다. 비동기라는 것은 요청해놓고 다른일을 하면서 기다리는 것이다. 프로미스는 비동기 처리 객체이기때문에 다른 것을 하다가 요청에 대한 응답이 왔을 때 그 요청에 대한 것을 이어서 처리하면 된다.","link":"/2020/01/10/Web/fetch-api-use/"},{"title":"[Web] MVC란?","text":"MVC?MVC는 Model View Controller 의 약자이다. 이는 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴이다. 구성 Model: 현재 상태, 각종 데이터를 포함한다. 예를들어 쇼핑몰이라면 가지고있는 상품 리스트 가격 등 이다. View: 특정 방식으로 Model의 데이터를 보기 좋게 하여 사용자에게 보여준다. Controller: 사용자로부터 입력을 받아 Model의 데이터를 수정하는 역할을 한다. 프로세스Controller는 Model에게 입력을 하고 변한 값들을 View에게 보내 보기 좋게 변경하여 사용자에게 다시 보내진다.","link":"/2020/01/01/Web/mvc/"},{"title":"[Web] Server side rendering VS Client side rendering","text":"Server side MVC와 Client side MVC의 차이는 무엇일까? 최근 react를 공부하게 되면서 이 둘의 차이를 공부해보았다. MVC에 대한 포스팅을 MVC 다음 포스팅을 확인해보자. Server side MVC 와 Client side MVC? 스마트폰의 사용자들이 많아지면서 스마트폰에 최적화된 웹 페이지가 중요해지기 시작했다. 스마트폰은 데스크탑에 비해 낮은 성능 때문에 이전의 방식으로 유지하기엔 어려움이 많았다. 따라서 다른 방법이 탄생했다. 바로 SPA(Single Page Application)이다. SPA는 최초에 한번 페이지 전체를 로딩한 이후, 필요한 부분만 데이터 요청을 하여 그 부분만 JS를 통해 렌더링 하는 방식이다. 이전의 방식(SSR)은 새로운 데이터가 필요할 때마다 페이지 전체를 렌더링 할 필요가 있었다. 그러나 SPA는 필요한 부분만 렌더링 하는 방식으로 트래픽을 감소시키고, 속도는 빨라졌다. 서버는 JSON으로 데이터만 전송하고 클라이언트에선 JS로 받은 데이터를 통해 html을 그리는 방식이다. SPA Framework에는 Angular JS, Backbone, React 등이 있다. 각 렌더링의 장단점CSR은 필요한 부분만 요청하여 데이터만 받아 특정 부분만 다시 그리면 되기 때문에 속도가 더 빨라진다. 그러나 단점도 존재한다. 초기 페이지를 읽는 시간, 자바스크립트를 읽는 시간, 자바스크립트가 화면을 그리는 시간이 소요되기 때문이다. 초기 페이지 로딩 시간이 길어질 수도 있다는 것이다. 그리고 검색엔진이 페이지를 읽지 못할 수 있다. 그 이유는 자바스크립트를 먼저 부른 뒤에 화면을 그린다. 그러나 검색엔진은 자바스크립트 파일을 실행시키지 못한다. 서버 사이드 렌더링은 클라이언트 사이드 렌더링의 반대이다. 초기 로딩 시간이 빠른 대신, 새로운 데이터를 불러올때마다 전체 페이지를 렌더링 해야하는 등의 단점이 있다. 결론적으로 어느 것을 사용해도 장단점은 있으며, 개발하고자 하는 도메인에 따라서 결정하도록 하자.","link":"/2020/01/02/Web/Server-side-rendering-VS-Client-side-rendering/"}],"tags":[{"name":"baekjoon","slug":"baekjoon","link":"/tags/baekjoon/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"부스트코스","slug":"부스트코스","link":"/tags/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BD%94%EC%8A%A4/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"browser","slug":"browser","link":"/tags/browser/"},{"name":"booster","slug":"booster","link":"/tags/booster/"},{"name":"protocol","slug":"protocol","link":"/tags/protocol/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"stl","slug":"stl","link":"/tags/stl/"},{"name":"next.js","slug":"next-js","link":"/tags/next-js/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"react.js","slug":"react-js","link":"/tags/react-js/"},{"name":"fetch","slug":"fetch","link":"/tags/fetch/"},{"name":"ajex","slug":"ajex","link":"/tags/ajex/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"rendering","slug":"rendering","link":"/tags/rendering/"}],"categories":[{"name":"Devlog","slug":"Devlog","link":"/categories/Devlog/"},{"name":"Boost Course","slug":"Devlog/Boost-Course","link":"/categories/Devlog/Boost-Course/"},{"name":"Algorithm","slug":"Devlog/Algorithm","link":"/categories/Devlog/Algorithm/"},{"name":"C++","slug":"Devlog/C","link":"/categories/Devlog/C/"},{"name":"Next.js","slug":"Devlog/Next-js","link":"/categories/Devlog/Next-js/"},{"name":"Web","slug":"Devlog/Web","link":"/categories/Devlog/Web/"}]}