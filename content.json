{"pages":[{"title":"","text":"About Kungbi ## **Intro.** 안녕하세요, 저는 신웅비입니다. 항상 호기심이 많고 컴퓨터를 좋아하는 초보 개발자 입니다. 어렸을 때부터 컴퓨터에 관심이 많아 직접 개발해보고 기술들을 공부하면서 개발자가 되어 사람들에게 좋은 영향을 줄 수 있는 소프트웨어를 개발하고자 개발자가 되었습니다. 메인포지션 할꺼없이 웹, 모바일, 인공지능, 보안 등 여러 분야들에 대해서 가리지않고 공부중입니다.(학생이라 시간이 많습니다.) 사람을 만나는 것을 좋아하고, 새롭게 알게되는 사람 또한 좋아합니다. 여러 사람들과 함께 IT이야기나 재미있는 이야기를 나누는 것을 좋아합니다. (근데 요즘 플스에 빠지게 되면서 집에서 잘 안나가고 있긴 하다.) 살짝 늦게 개발 블로그를 시작하긴 했지만, 지금이라도 제가 공부한 것들이라 저의 일상을 기록하면서 추억과 경험을 남기고 한편으로 반성을 하고자 시작했습니다. 개발 프로젝트 외출: 외대인 솔로탈출 미팅 매칭 서비스2019.08.20 ~ 2018.11.06 ViDEEP: 영상 유해도 분석기2018.05.07 ~ 2018.07.08 딥러닝 기법을 이용한 가짜뉴스 탐지2018.05.07 ~ 2018.07.08 다이어리 톡: 일기와 메신저를 더하다2017.01.02 ~ 2017.05.28 태릉고등학교 공식 어플리케이션2017.06.01 ~ 2017.07.02 Tip Toe: 위치기반 음악 추천 스트리밍 서비스2017.02.25 ~ 2017.02.26 학교 도움이 어플리케이션2015.08.02 ~ 2015.09.03 C언어기반 슈팅 게임2015.06.01 ~ 2015.07.02 수상 2018년 춘계 학술대회 - 최우수 논문상(1위) 2018년 올림피아드 공모전 - 은상 2017년 예술해커톤 : 예술 데이터 - 최우수상(1위) 약력 한국외국어대학교 글로벌캠퍼스 재학중 원묵초/원묵중/태릉고 졸업 서울 출생","link":"/about/index.html"}],"posts":[{"title":"백준 10837번 문제","text":".","link":"/2020/02/11/Algorithm/baekjoon-10837/"},{"title":"백준 10840번 문제","text":".","link":"/2020/02/11/Algorithm/baekjoon-10840/"},{"title":"[알고리즘] Intro","text":"고등학교때 잠깐 알고리즘 공부를 했었는데, 그땐 별로 재미없기도 하고 할 이유가 별로 없어서 바로 그만뒀던 것 같다. 이제 곧 대학 수업에 알고리즘도 들어가고 코테준비도 하고 그러려면 지금부터 알고리즘을 공부해야할 것 같다. 그래서 이렇게 카테고리를 만들어서 공부를 시작해보려고 합니다.","link":"/2020/01/20/Algorithm/new-category-algorithm/"},{"title":"[부스트코스] 브라우저의 작동 방식","text":"오늘은 웹브라우저가 어떻게 렌더링과정을 거쳐서 화면에 보이게 되는지에 대해서 강의를 듣고 공부를 했다. 웹브라우저가 서버로부터 리소스를 받으면 어떤 과정으로 처리하고, 화면에 보이기 까지 과정을 포스팅 하려고 한다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. 브라우저의 주요기능 서버와의 통신을 담당한다. 서버로 부터 받은 리소스(HTML, PDF, 이미지, 동영상 등)을 화면에 표시될 수 있도록 한다. HTML, CSS, JavaScript 를 해석해서 화면에 그려준다. 브라우저의 대표적인 기능은 화면에 받은 리소스들을 해석해 표현하는 것이라 볼 수 있다. 그렇다면 이를 어떤 방식으로 처리하는지 알아보자. 일단 브라우저의 구조부터 확인하자. 브라우저 기본 구조브라우저는 여러 많은 종류가 있다. Chrome, Explorer, Firefox 등 말이다. 그런데 기본적인 구조는 동일하다. 다음은 브라우저의 기본 구조이다. #### 사용자 인터페이스 주소 표시줄, 이전/다음 버튼, 북마크 등 사용자가 직접 볼 수 있고, 활용할 수 있는 서비스들. 브라우저 엔진사용자 인터페이스와 렌더링 엔진 사이의 동작 제어. 렌더링 엔진받은 리소스들을 표시, HTML CSS JavaScript를 해석해 화면에 그려준다. 통신HTTP 요청과 같은 네트워크 통신에 사용된다. 자바스크립트 해석기자바스크립트 코드를 해석한다. UI 백엔드플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용. 자료 저장소쿠키와 같이 계속 저장해야하는 데이터를 저장하는 곳. 렌더링 엔진이번 포스팅에서 주요하게 봐야할 주제를 렌더링 이다. 렌더링을 하기 위해선 렌더링 엔진을 이해하는 것이 중요하다. 렌더링 엔진은 HTML 및 XML 문서와 이미지를 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF와 같은 다른 유형도 표시할 수 있다. 렌더링 엔진은 여러 종류가 있는데, 게코(Gecko), 블링크(Blink), 웹키트(Webkit) 등 여러개가 존재한다. 동작 과정 1. **DOM** 이란 Document Object Model 이다. HTML를 하나의 **객체 트리**로 만들어, 프로그래밍 언어(JavaScript)가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다. DOM은 HTML을 토대로 객체로 만들어 트리형식으로 DOM 트리 를 구축하게 된다. 그리고 외부 CSS파일과 함께 포함된 스타일 요소들을 파싱한다. 스타일 정보와 HTML 표시 규칙은 렌더 트리 라는 또하나의 트리를 생성한다. 렌더 트리 생성이 끝나면 배치가 시작되는데 이것은 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다. 마지막으로 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어 내는 그리기 과정 이다. ❖ 이 과정은 1, 2, 3, 4 순서대로 동기적으로 이루어지는 것이 아니라 모든 HTML이을 파싱할할때 까지 기다리지 않고 파싱이 되는대로 배치 -&gt; 그리기를 반복한다고 한다. 웹사이트에 들어가게 되면 한번에 뜨지않고 부분부분 나오는 이유. 동작 과정 예 --- 파싱과 DOM 트리 구축파싱은 렌더링에서 매우 중요한 개념이다. 문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미한다. 123456&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;div&gt;&lt;img src=\"example.png\" /&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 다음과 같이 html 태그 아래 body태그 아래 p태그 와 div태그가 있고 p 태그 아래에는 텍스트가 div태그 아래에는 img 태그가 존재한다. 이를 파싱해 트리형태로 DOM을 구현한다.","link":"/2020/01/30/Booster/how-browser-work/"},{"title":"[부스트코스] HTTP 프로토콜이란?","text":"웹 브라우저와 웹 서버 간에 서로 통신하기 위해서는 일종의 규약이 필요하다. 이때 필요한 규약이 HTTP이다. 이번 포스팅에선 HTTP에 대하여 글을 써보려고 한다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. HTTP(Hypertext Transfer Protocol) 이란?HTTP는 인터넷에서 데이터를 주고받기 위한 프로토콜이다. 프로토콜을 쉽게 말해서 규칙이라 보면 된다. 로컬에서만 동작하는(인터넷을 사용하지 않는) 소프트웨어가 아닌, 서버와 상호작용하는 소프트웨어를 개발한다면 HTTP Protocol에 대해서 기본적인 개념을 알아야 한다. HTTP는 1989년 **팀 버너스리(Tim Berners-Lee)** 에 의해 처음 설계되어 인터넷을 통한 **World Wide Web(WWW)**을 기반으로 전 세계적인 정보공유를 이루는데 큰 역할을 했다. HTTP 말 그대로 hyper 초월의 뜻으로 hypertext는 그저 텍스트가 아닌 그 이상을 뛰어넘어 이미지, 동영상, 오디오 등을 표현할 수 있다는 의미로 해석하면 된다. HTTP는 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 한 지점에서 다른 지점으로 요청과 응답을 전송한다. HTTP 작동 방식 HTTP는 기본적으로 **Request(요청)**과 **Response(응답)** 으로 나뉜다. **클라이언트(브라우저)**가 서버에 접속하면 Request를 하게 되고 **서버**에선 Request에 따라서 맞는 Response를 하게 된다. 만약 http://naver.com 에 접속하게 된다면, 네이버 서버는 네이버 홈페이지를 응답하게 되고 https://news.naver.com 에 접속하면 네이버는 네이버 뉴스 페이지를 응답하게 된다. HTTP 특징 HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.따라서 서버 간의 최대 연결 수보다 훨씬 많은 요청과 응답을 처리할 수 있다.그러나 연결을 끊어버리기 때문에, 클라이언트의 이전 상황을 알 수가 없다. 이러한 단점을 해결하기 위해 Cookie와 Seesion 등장하게 된다. HTTP는 연결을 유지하지 않는 프로토콜이기 떄문에 요청/응답(request/response) 방식으로 동작한다. URL(Uniform Resorce Locator)1http://kungbi.github.io URL은 인터넷 상의 자원(컴퓨터)가 어디에 있는지를 알려주기 위한 규약이다. 집 주소(도로명 주소)와 똑같은 개념이다. URL에 접속하기 위해선 해당 URL에 맞는 프로토콜을 알아야 하고, 그와 동일한 프로토콜로 접속해야 한다. HTTP Header **HTTP Header**은 웹브라우저가 HTTP프로토콜을 이용해 요청 정보를 웹 서버로 전송할 때 HTTP 요청 헤더에 **부가적인 정보**를 담아 전송한다. 대표적인 몇가지를 소개하려고 한다. 요청 URL 요청을 하는 자원의 URL 의미한다. 요청 메서드 GET : 정보를 요청하기 위해 사용. POST: 정보를 입력하기 위해 사용. PUT : 정보를 수정하기 위해 사용. DELETE : 정보를 삭제하기 위해 사용. … 쿠키 HTTP의 비연결성의 단점을 해결하기 위해 사용자의 상태 정보를 저장하는 것을 쿠키라 한다. 요청을 할시에 쿠키를 같이 전송하여 인증을 시행한다. ex) 자동 로그인, 로그인 상태 유지 HTTPS? **HTTPS**는 **HTTP**와 같은 통신 프로토콜이다. 사용방식 또한 HTTP와 거의 비슷하다. HTTP와 HTTPS와의 차이점은 HTTP의 취약점을 보완한 것에 있다. HTTP는 서버와 주고받는 패킷이 암호화 처리가 되어 있지 않아 만약 중간에 패킷을 가로챈다면 보안상 치명적인 결과를 가져올 수 있다. 그래서 HTTPS는 HTTP의 취약점을 보완하기 위해 주고받는 모든 메시지를 암호화한다. 즉, 중간에 패킷을 가로챈다고 해도 암호화된 내용이 노출되기 떄문에 보안상 안전하고, 공유된 대칭키를 모르는 상황에서 암호화를 푼다는 것은 모든 경우의 키를 대입해야한다는 것이다. 만약 1024 비트(보통은 128비트 암호화)의 암호화라면, 평균적으로 2의 512승을 대입해야하며, 이것은2475880078570760000000000000.00이라는 수를 대입해야 한다는 뜻과 같다고 한다.","link":"/2020/01/29/Booster/http-protocol/"},{"title":"부스트코스 서포터즈 BOOSTER","text":"edwith는 네이버(NAVER)와 커넥트재단(CONNECT)이 비영리로 운영중인 MOOC사이트이다. MOOC은 온라인 공개수업(Massive Open Online Course)을 의미한다. 그래서 이번에 부스트코스 서포터즈 BOOSTER 2기를 모집하길래 어떤 활동인지 알아보았다. 생각보다 체계적인 운영 방식으로 되어있었다. 지원하기 전 강의를 몇개 구경했는데 강의 품질도 좋았다. 제일 좋았던 부분은 프로젝트 미션이 있다는 것이다. 사실 개념만 공부만 하다보면 피곤하기도하고 재미도 없다. 근데 부스트코스는 프로젝트 미션과 함께 실제 현업 전문가가 코드리뷰를 해서 피드백을 받을 수 있다. 게다가 모두 수료하면 기업 연계 기회도 준다고 한다(사실 네이버가 하는거면 다 좋아보인다.)). 다른 신기한 점은, 부스트코스에서 블로그 운영, 포스팅을 유도한다. 개발자라면 하나씩 있어야하는 개발 블로그, 보통의 컴공 대학생은 개발 블로그를 운영하지 않는다. 그래서 부스트코스는 대학생들에게 정말 도움되는 활동이 아닌가 싶다. 나도 부스트코스를 하면서 글을 주기적으로 올리려고한다. 할튼간에 부스트코스 서포터즈 BOOSTER 2기에 합격했기 때문에, 앞으로 강의를 들으면서 배운점 공유하고싶은 부분은 글을 쓰려고한다.","link":"/2020/01/26/Booster/new-category-boostcourse/"},{"title":"[C++] STL 이란","text":"C++ 공부와 알고리즘 공부 차원에서 STL에 대해서 알아보았다. STL이란 표준 C++ 라이브러리(Standard Template Library) 프로그램에 필요한 자료구조와 알고리즘을 템플릿으로 제공하는 라이브러리 STL 구성 요소ContainerSTL 데이터를 보관하기 위한 다양한 컨테이너를 제공한다. 컨테이너는 데이터를 저장하는 객체이다. Sequence containers array vector deque forward_list list Associative containers set multiset map multimap Unordered associative containers unordered_set unordered_multiset unordered_map unordered_multimap Container adaptors stack queue priority_queue Iterator포인터처럼 컨테이너 원소를 가리키고, 가리키는 원소의 다음 원소를 가리길 수 있는 기능이다. 데이터들을 순회할 수 있는 반복자이다. Algorithm정렬, 삭제, 검색, 연산 등을 해결하는 알고리즘 제공. FunctorSTL에는 함수 호출 연산자를 오버로드하는 클래스가 포함되어 있다. 이러한 클래스의 인스턴스를 함수 객체 또는 펑터라고한다. 펑터를 사용하면 매개 변수를 통해 관련 기능의 작업을 사용자 정의 할 수 있다.","link":"/2020/02/04/C++/what-is-stl/"},{"title":"Next.js - Link API 라우팅","text":"Next.js의 핵심 기능 중 하나인 Link API 라우팅 에 대해서 알아보려고 한다. Link API는 손쉽게 라우팅을 할 수 있게 해주는 API이다. Next.js의 핵심 기능 중 하나이다. 우선 Link API를 사용하려면 라이브러리를 import 해주어야 한다. 1import Link from 'next/link'; pages/index.js 로 가서 코드를 수정해 보자. 12345678910111213141516import Link from 'next/link';const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;Link href='/about'&gt; &lt;a&gt;Link API - About&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt;);export default Index; 그리고 localhost:3000 으로 들어가 Link API - About 를 클릭해보면 about 페이지로 넘어간다. 그렇다면 우리가 평소에 사용했었던 &lt;a&gt; 태그를 사용해보자. 12345678910111213141516171819import Link from 'next/link';const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;Link href='/about'&gt; &lt;a&gt;Link API - About&lt;/a&gt; &lt;/Link&gt; &lt;br/&gt; &lt;a href='/about'&gt;A tag - About&lt;/a&gt; &lt;/div&gt;);export default Index; 둘의 차이를 확인해보자. 다른 것이 보일 것이다. &lt;a&gt;태그를 활용한 페이지 이동은 새로고침을 하여서 다시 SSR을 하게 된다. 반면 Link API를 활용한 페이지 이동은 새로고침을 하지 않고 CSR을 하게 된다.","link":"/2020/01/03/Next.js/Next.js%20Link%20API/"},{"title":"Next.js - Component 생성","text":"React에서 component를 생성해서 여러가지 방법으로 재사용하고 편리하게 화면을 구성할 수 있는 요소이다. Next.js에서 component를 어떻게 생성하는지 알아보았다. 컴포넌트 디렉토리Next.js에서 컴포넌트를 생성하기 위해선 components 디렉토리가 필요하다. 최상위 디렉토리에서 components 디렉토리를 생성하자. components디렉토리에 컴포넌트를 생성하지 않으면 오류가 발생한다. 헤더 컴포넌트 생성components/Header.js 를 생성한다. 그리고 다름 코드를 작성하였다. 123456789101112131415161718192021222324252627import Link from 'next/link';const LinkStyle = { marginRight: '1rem', fontSize: '1.5rem'};const HeaderStyle = { border: '0.5rem dashed pink', borderRadius: '10px', margin: '1rem', padding: '1rem'};const Header = () =&gt; ( &lt;div style={HeaderStyle}&gt; &lt;Link href=\"/\"&gt; &lt;a style={LinkStyle}&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;Link href=\"/about\"&gt; &lt;a style={LinkStyle}&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt;);export default Header; 컴포넌트 importpages/index.js 와 pages/about.js 에서 components/Header.js 를 사용해보자. 12345678910111213141516171819202122import Link from 'next/link';import Header from '../components/Header';const Index = () =&gt; ( &lt;div&gt; &lt;Header/&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;Link href='/about'&gt; &lt;a&gt;Link API - About&lt;/a&gt; &lt;/Link&gt; &lt;br/&gt; &lt;a href='/about'&gt;A tag - About&lt;/a&gt; &lt;/div&gt;);export default Index; 12345678910import Header from \"../components/Header\";const About = () =&gt; ( &lt;div&gt; &lt;Header/&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/div&gt;);export default About; 결과 레이아웃 컴포넌트레아아웃 컴포넌트는 페이지를 구성한는 여러가지 컴포넌트를 사용해 웹사이트 전체적인 레이아웃을 구성한다. 이점은 여러페이지 마다 많은 컴포넌트를 사용하지 않고 레이아웃 컴포넌트 하나만 사용하면 되고 유지보수 측면으로도 간편하기 때문이다. 그러면 components/BaseLayout.js 를 생성하여 다음 코드를 작성하자. 12345678910import Header from \"./Header\";const BaseLayout = (props) =&gt; ( &lt;div&gt; &lt;Header/&gt; {props.children} &lt;/div&gt;);export default BaseLayout 그리고 index.js 와 about.js 도 다음과 같이 수정하자. 123456789101112131415161718192021import Link from 'next/link';import BaseLayout from '../components/BaseLayout'const Index = () =&gt; ( &lt;BaseLayout&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;Link href='/about'&gt; &lt;a&gt;Link API - About&lt;/a&gt; &lt;/Link&gt; &lt;br/&gt; &lt;a href='/about'&gt;A tag - About&lt;/a&gt; &lt;/BaseLayout&gt;);export default Index; 123456789import BaseLayout from \"../components/BaseLayout\";const About = () =&gt; ( &lt;BaseLayout&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/BaseLayout&gt;);export default About; 결과결과는 이전과 같을 것이다. 그러나 레이아웃 컴포넌트를 통해 유지보수가 더 간편해지고(Header.js를 수정하면 모든 페이지의 Header를 변경할 수 있다.), 많은 페이지 개발이 필요하다면 BaseLayout.js를 통해 간편하게 개발할 수 있을 것이다.","link":"/2020/01/09/Next.js/next.js_make_component/"},{"title":"Next.js로 프로젝트 생성하기","text":"이번 포스팅은 Next.js로 프로젝트를 생성하는 것에 대해서 작성해보려고 한다. 설치12345$ mkdir todo-list$ cd todo-list$ yarn init -y$ yarn add react react-dom next$ mkdir pages 그리고 “package.json” 파일을 수정하자. 다음과 같이 npm 스크립트를 추가하면 된다. 12345\"scripts\": { \"dev\": \"next\", \"build\", \"next build\", \"start\", \"next start\"}, 다음 명령어로 개발 서버를 실행할 수 있다. $ npm run dev 다음과 같이 출력되면 서버가 정상적으로 실행된 것이다. http://localhost:3000 으로 접속할 수 있다. 404 페이지그러면 다음과 같이 보이게 된다. 404에러가 출력되면서 페이지가 없다고 한다. 그러면 페이지를 만들어보자. 페이지 생성index.js 파일 생성pages폴더에 index.js 파일을 생성해서 다음과 같이 수정해 보자. 123456789const Index = () =&gt; ( &lt;div&gt; &lt;h1&gt; Hello, World! &lt;/h1&gt; &lt;/div&gt;);export default Index; 주의 사항next.js를 사용하면서 꼭 지켜야할 규칙들이 있다. pages 폴더가 꼭 필요하다. 그리고 라우팅 URL과 컴포넌트의 이름이 같아야 한다. 예를 들어서 url이 /about이라면 pages/about.js파일을 만들어야 한다.","link":"/2020/01/03/Next.js/make_project_with_nex.js/"},{"title":"Next.js란?","text":"학교 프로젝트를 하다가 웹사이트를 만들어야할 필요가 있어서 Next.js라는 친구를 공부해봤다. 괜찮았고, 계속 공부해볼만한 가치가 있었다. Next.jsReact 프로젝트를 시작할 때 많은 사람들이 Create React App을 사용했을 것이다. CRA는 기본적인 React 프로젝트를 생성하기에 좋은 툴이다. 그러나 CRA는 서버에서 페이지를 렌더링 하지 않는다. 오직 클라이언트 사이드 렌더링만 지원한다. 그리고 러닝 커브가 높다. 클라이언트 사이드 라우팅과 페이지 레이아웃 등을 공부해야 하기 때문이다. 이를 해결하고 간편하게 React 프로젝트를 생성할 수 있게 도와주는 Next.js를 소개한다. PHP로 만든 웹페이지를 생각해보자. 라우팅에 대해서 전혀 걱정하지 않았을 것이다. 그러나 React는 따로 라우팅을 해주어야 한다. 이를 대신 처리해 주는 것이 React.js 전용 프레임 워크인 Next.js이다. Next.js의 장점 기본적으로 서버 사이드 렌더링을 해준다. 그래서 클라이언트의 초기 렌더링 속도를 향상 시켜줌. 빠른 속도를 위해 code-splitting을 지원한다. 클라이언트 사이드 라우팅도 지원한다. Next.js 동작 방식SSR은 서버에서 렌더링 하는 것이다. PHP, JSP가 대표적인 SSR 프레임 워크이다. 미리 html을 작성하여 어떤 유저가 url에 접근하면 그 url에 맞는 html을 전송하는 방식이다. next.js에서의 SSR도 다르지 않다. 서버(node.js)를 실행하고 사용자가 요청하면 html을 생성하여 사용자에게 전송한다. 다른 점은 모든 요청에 대해서 SSR을 하는 것이 아니라, 초기 렌더링만 해당한다. 그 이후로는 next/router를 통해 렌더링 한다. 이러한 방식으로 SPA의 단점인 초기 렌더링 시간을 줄일 수 있다. CSR은 Client Side Rendering이다. CSR은 HTML, CSS, JS를 받고 그 이후에 렌더링을 시작한다. Next.js는 다음과 같은 순서로 실행 된다. 유저가 페이지에 접속한다. 실행되고 있는 node 서버가 요청을 받고 서버 렌더링을 한다. 만들어진 HTML을 전송한다. 사용자가 다른 경로(링크)를 클릭하면, 해당 URL로 라우팅한다. 그리고 해당 페이지 코드를 렌더링 한다.","link":"/2020/01/03/Next.js/what_is_Next.js/"},{"title":"Next.js - 게시판 만들기","text":"이전 포스팅에선 Link API를 사용해서 다른 페이지로 넘어가는 것을 구현했다. 이번 포스팅에서는 간단한 게시판(DB사용 X)을 만들어보려고 한다. 게시물 목록 구현우선 게시물 페이지로 넘어가기 위한 게시물 목록을 만들어보자. components/PostLink.js 파일을 생성하여 다음 코드를 작성하자. 123456789import Link from 'next/link';export default (props) =&gt; ( &lt;li&gt; &lt;Link href={`/post?id=${props.id}`}&gt; &lt;a style={{fontSize: '1.5rem'}}&gt;{props.title}&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;); posts/index.js 를 다음과 같이 수정했다. 12345678910111213141516171819202122232425262728293031323334import BaseLayout from '../components/BaseLayout';import PostLink from '../components/PostLink';const posts = [ {id:1, title: \"Post Title #1\", content: \"#1 content\"}, {id:2, title: \"Post Title #2\", content: \"#2 content\"}, {id:3, title: \"Post Title #3\", content: \"#3 content\"}, {id:4, title: \"Post Title #4\", content: \"#4 content\"}, {id:5, title: \"Post Title #5\", content: \"#5 content\"}, {id:6, title: \"Post Title #6\", content: \"#6 content\"}, {id:7, title: \"Post Title #7\", content: \"#7 content\"}, {id:8, title: \"Post Title #8\", content: \"#8 content\"}, {id:9, title: \"Post Title #9\", content: \"#9 content\"}];const PostList = () =&gt; ( &lt;&gt; {posts.map((data, index) =&gt; { return &lt;PostLink id={data.id} title={data.title} key={index}/&gt; })} &lt;/&gt;);const Index = () =&gt; ( &lt;BaseLayout&gt; &lt;h1&gt; Next.js Main Page. &lt;/h1&gt; &lt;PostList/&gt; &lt;/BaseLayout&gt;);export default Index; posts 변수는 게시물 목록 더미데이터 이다. 그리고 map 함수로 posts 데이터들을 사용해 &lt;PostLink&gt; 컴포넌트를 생성했다. 그러면 다음과 같이 화면에 출력된다. 게시물 세부 내용 확인 페이지이번엔 각 게시물을 볼 수 있도록 게시물을 보는 페이지를 만들어보자. pages/post.js 파일을 생성해서 다음의 코드를 작성했다. 123456789101112131415161718192021222324252627282930313233343536373839import BaseLayout from \"../components/BaseLayout\";import {useRouter} from 'next/router';const posts = [ {id:1, title: \"Post Title #1\", content: \"#1 content\"}, {id:2, title: \"Post Title #2\", content: \"#2 content\"}, {id:3, title: \"Post Title #3\", content: \"#3 content\"}, {id:4, title: \"Post Title #4\", content: \"#4 content\"}, {id:5, title: \"Post Title #5\", content: \"#5 content\"}, {id:6, title: \"Post Title #6\", content: \"#6 content\"}, {id:7, title: \"Post Title #7\", content: \"#7 content\"}, {id:8, title: \"Post Title #8\", content: \"#8 content\"}, {id:9, title: \"Post Title #9\", content: \"#9 content\"}];const Content = () =&gt; { const router = useRouter(); const post = posts[router.query.id -1]; const title = post.title; const content = post.content; return( &lt;&gt; &lt;h1&gt;{title}&lt;/h1&gt; &lt;p&gt;{content}&lt;/p&gt; &lt;/&gt; );}const Post = (props) =&gt; { return( &lt;BaseLayout&gt; &lt;Content/&gt; &lt;/BaseLayout&gt; );};export default Post; next/router 로 현재 파라미터를 받아와서 해당 데이터를 posts json변수에서 받아온다. 그리고 title과 content를 추출해 화면에 출력했다.","link":"/2020/01/12/Next.js/next-js-make-board_1/"},{"title":"Fetch API 사용하기","text":"fetch()는 네트워크 요청을 쉽게 활용할 수 있게 만들어준다. api를 가져올 때 예전에는 XMLHttpRequest을 사용했다. 이 포스팅에서는 보다 편리하게 개발할 수 있게 도와주는 fetch를 사용하여 쉽게 데이터를 가져오는 방법을 포스팅 하려고 한다. Fetch API 사용법일반적인 Fetch API 문법#1: 데이터만 가져올 때1fetch(url) #2: 데이터를 받아와 이후에 처리할 내용이 있다면123fetch(url).then(function(response) { // Code ...}); Fetch API 옵션 및 파라미터12345678fetch(url, { method: 'GET', headers: { 'Content-Type': 'application/json' }}).then(function(response) { // Code ...}) api를 통해 연습해보기랜덤으로 유저 정보를 생성해서 정보를 제공하는 API가 있다. 이 API를 통해서 fetch를 연습해보자. 랜덤 유저 생성기랜덤유저생성기는 자동으로 유저 정보를 생성해준다. 10명의 정보를 가져오려 한다면 파라미터로 ?result=10이라고 붙여주면 된다.그러면 fetch로 랜덤 유저 생성기 API를 사용해 결과를 콘솔 로그창에 출력해보자. Chrome의 개발자모드로 들어가 Console에서 로그를 확인 할 수 있다. 위의 코드를 실행하면 “프로미스”라는 값을 받게 된다. 프로미스는 자바스크립트의 비동기 처리에 활용되는 객체 이다. 동기라는 것은 프로그램이 끝날 때까지 다른 일은 하지 않는 것이다. 비동기라는 것은 요청해놓고 다른일을 하면서 기다리는 것이다. 프로미스는 비동기 처리 객체이기때문에 다른 것을 하다가 요청에 대한 응답이 왔을 때 그 요청에 대한 것을 이어서 처리하면 된다.","link":"/2020/01/10/Web/fetch-api-use/"},{"title":"[Web] MVC란?","text":"MVC?MVC는 Model View Controller 의 약자이다. 이는 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴이다. 구성 Model: 현재 상태, 각종 데이터를 포함한다. 예를들어 쇼핑몰이라면 가지고있는 상품 리스트 가격 등 이다. View: 특정 방식으로 Model의 데이터를 보기 좋게 하여 사용자에게 보여준다. Controller: 사용자로부터 입력을 받아 Model의 데이터를 수정하는 역할을 한다. 프로세스Controller는 Model에게 입력을 하고 변한 값들을 View에게 보내 보기 좋게 변경하여 사용자에게 다시 보내진다.","link":"/2020/01/01/Web/mvc/"},{"title":"[Web] Server side rendering VS Client side rendering","text":"Server side MVC와 Client side MVC의 차이는 무엇일까? 최근 react를 공부하게 되면서 이 둘의 차이를 공부해보았다. MVC에 대한 포스팅을 MVC 다음 포스팅을 확인해보자. Server side MVC 와 Client side MVC? 스마트폰의 사용자들이 많아지면서 스마트폰에 최적화된 웹 페이지가 중요해지기 시작했다. 스마트폰은 데스크탑에 비해 낮은 성능 때문에 이전의 방식으로 유지하기엔 어려움이 많았다. 따라서 다른 방법이 탄생했다. 바로 SPA(Single Page Application)이다. SPA는 최초에 한번 페이지 전체를 로딩한 이후, 필요한 부분만 데이터 요청을 하여 그 부분만 JS를 통해 렌더링 하는 방식이다. 이전의 방식(SSR)은 새로운 데이터가 필요할 때마다 페이지 전체를 렌더링 할 필요가 있었다. 그러나 SPA는 필요한 부분만 렌더링 하는 방식으로 트래픽을 감소시키고, 속도는 빨라졌다. 서버는 JSON으로 데이터만 전송하고 클라이언트에선 JS로 받은 데이터를 통해 html을 그리는 방식이다. SPA Framework에는 Angular JS, Backbone, React 등이 있다. 각 렌더링의 장단점CSR은 필요한 부분만 요청하여 데이터만 받아 특정 부분만 다시 그리면 되기 때문에 속도가 더 빨라진다. 그러나 단점도 존재한다. 초기 페이지를 읽는 시간, 자바스크립트를 읽는 시간, 자바스크립트가 화면을 그리는 시간이 소요되기 때문이다. 초기 페이지 로딩 시간이 길어질 수도 있다는 것이다. 그리고 검색엔진이 페이지를 읽지 못할 수 있다. 그 이유는 자바스크립트를 먼저 부른 뒤에 화면을 그린다. 그러나 검색엔진은 자바스크립트 파일을 실행시키지 못한다. 서버 사이드 렌더링은 클라이언트 사이드 렌더링의 반대이다. 초기 로딩 시간이 빠른 대신, 새로운 데이터를 불러올때마다 전체 페이지를 렌더링 해야하는 등의 단점이 있다. 결론적으로 어느 것을 사용해도 장단점은 있으며, 개발하고자 하는 도메인에 따라서 결정하도록 하자.","link":"/2020/01/02/Web/Server-side-rendering-VS-Client-side-rendering/"},{"title":"[부스트코스] WAS란?","text":"이번 포스팅은 WAS가 무엇이고, 왜 필요한지 그리고 어떤 WAS가 있어며 웹서버와의 차이점에 대해서 다뤄보려고 한다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. WAS(Web Application Server) 웹 애플리케이션과 서버환경을 만들어 동작시키는 기능을 제공하는 프레임워크이다. HTTP를 통해 접속한 클라이언트에게 애플리케이션을 제공하기 위해 서버 사이드에서 작동한다. 동적인 페이지를 표현하기 위해 사용된다. 클라이언트 &lt;–&gt; 서버 와의 통신 과정 Web Browser: 클라이언트 요청. Web Server: WAS에게 요청. Web Application Server: 처리 수행. Database: 처리 수행. Web Application Server: 결과를 웹서버에게 응답. Web Server: 응답. Web Browser DBMS(Database Management System)DBMS가 만들어지고 초반에는 클라이언트와 DB는 직접 연결되어 있었다. 그래서 그 당시 DB에 접속하여 동작하는 클라이언트 프로그램들이 많이 만들어졌다. 그러나 클라이언트의 로직이 많아지고, 클라이언트의 프로그램 크기가 커지게 되는 문제점이 존재했다. 그리고 한번 로직이 변경되면 클라이언트 프로그램을 다시 배포해야한다는 불편함도 있었다. 게다가 직접 연결하게 되면 보안상의 이유로도 문제가 존재했다. 미들웨어(Middle Ware)클라이언트와 DB가 직접 연결되는 방식은 문제점이 있었다. 그래서 생겨난 것이 바로 미들웨어이다. 미들웨어는 클라이언트와 DB서버 사이에 존재한다. 양쪽에서 데이터를 주고받을 수 있도록 중간에서 매개역할을 하는 소프트웨어이다. 이 미들웨어를 통해서 표준화된 인터페이스를 제공할 수 있으며, 부하 분산을 할 수 있다. 또한 프로그램 로직이 바뀌더라도 다시 배포하지 않고 중앙의 미들웨어만 변경하면 된다. WAS웹이 점점 복잡해지고 점점 복잡한 프로그래밍적인 기능을 요구하게 되었다. 보통 이러한 기능들을 DBMS와의 연관된 경우가 많다고 한다. 그래서 이를 단순화 하고 편리성을 위해 클라이언트와 DBMS사이에 미들웨어가 필요하게 된것이다. 이러한 미들웨어를 WAS라고 한다. WAS도 큰 의미로 미들웨어라고 볼 수 있다. WAS의 세가지 중요 기능 프로그램 실행 환경, 데이터베이스 접속 기능. 여러개의 트랜젝션 관리 기능. 업무를 처리하는 비즈니스 로직 수행 기능. 이렇게 보면 클라이언트의 요청을 처리하는 웹서버가 필요없다고 볼 수도 있다. 왜냐하면 WAS자체의 웹서버가 충분한 기능을 가지고 있기 때문이다. WAS vs Webserver웹서버를 사용하지않고 WAS만 사용해도 될 것 같다. 그러나 대부분의 서비스를 보면 이 둘다 사용한다. 그 이유는 무엇일까? 웹서버는 WAS보다 간단한 구조로 만들어져있다. 사람들이 많이 접속하는 대용량 웹 어플리케이션 같은 경우에는 서버의 수가 여러대일 수도 있다. 가끔씩 개발자의 실수로 서버들 중에 하나가 오작동이 되어 WAS 자체에 문제가 발생하는 경우가 있다. 이런 경우 WAS를 재시작해야한다. 이때 웹서버에서는 문제의 WAS를 이용하지 못하도록 막아놓고 WAS 재시작하면 실제 사용자는 서버가 중단이 됐는지 모르고 이용할 수 있다. 이러한 처리를 장애 극복 기능이라 한다. WAS - Apache Tomcat아파치 소프트웨어 재단의 애플리케이션 서버로 자바서블릿을 실행하고 JSP 코드가 포함되어 있는 웹페이지를 만들어준다 / 자체적으로 보유하고 있는 내부 웹서버와 함께 독립적으로 사용될 수 있지만, 아파치 HTTP 웹 서버나 넷스케이프 엔터프라이즈 서버, IIS 등 다른 웹서버와 함께 사용될 수도 있다 / servlet과 JSP script를 지원하도록 개발했다. 다음은 Tomcat 버전별 서블릿, JSP, EL Spec, WebSocket, JAVA 지원 버전 목록표이다.","link":"/2020/02/13/Booster/what-is-was/"},{"title":"[부스트코스] Servlet.","text":"이번 포스팅은 자바 웹 어플리케이션의 구조와 Servlet이 무엇인지에 대해서 포스팅 하려고 한다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. 자바 웹 어플리케이션 구조 web.xml 파일 배포 기술자라고도 불린다. 웹 애플리케이션에 대한 정보들을 가지고있는 파일. servlet 3.0 미만에서는 필수로 가지고 있어야 함.servlet 3.0 이상에서는 어노테이션을 사용해서 대신해주는 부분들이 존재하기 떄문에 반드시 꼭 포함하지는 않아도 된다. lib 폴더각종 자료 파일들 저장 classes 폴더java 패키지, class들, servlet 파일이 저장된다. WEB-INF 폴더 이외의 폴더들 각종 폴더들을 생성할 수 있다. 프론트엔트 리소스(HTML, CSS, JavaScript 등) 저장. 그 외에도 이미지 폴더, 다양한 리소스들을 저장 가능. Servlet 이란?자바 웹 어플리케이션 구성요소 중 동적인 처리를 하는 프로그램의 역할을 한다. 서블릿은 WAS에서 동작하는 Java 클래스이다. 서블릿은 HttpServlet 클래스를 상속받아야 한다. 서블릿과 JSP로부터 최상의 결과를 얻으려면 웹 페이지를 개발할 때 이두가지(JSP, Servlet)를 조화롭게 사용해야한다.예) 웹 페이지를 구성하는 화면은 JSP로 표현하고 복잡한 프로그래밍은 서블릿으로 구현","link":"/2020/02/21/Booster/waht-is-servlet/"},{"title":"[부스트코스] Servlet의 life cycle","text":"서블릿의 생명주기에 대해서 포스팅 해보려 한다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. LifecycleServlet주요 서블릿 메소드 init() service(request, response) destroy() 서블릿 생명주기 순서init() -&gt; service() -&gt; destroy() WAS는 서블릿 요청을 받으면 해당 서블릿이 메모리에 존재하는지 확인한다. 서블릿이 메모리에 존재하는지 확인 메모리에 서블릿이 존재한다면 service() 메소드를 실행한다. 메모리에 서블릿이 존재하지 않다면 init() 메소드를 실행한다. WAS가 종료되거나, 웹 어플리케이션이 다른 코드로 갱신되면 destory() 메소드를 실행한다. 실습코드1234567891011121314151617181920212223242526272829303132package examples;import java.io.IOException;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/LifeCycleServlet\")public class LifeCycleServlet extends HttpServlet { private static final long serialVersionUID = 1L; public LifeCycleServlet() { super(); System.out.println(\"LifeCycleServlet 생성.\"); } public void init(ServletConfig config) throws ServletException { System.out.println(\"init 호출.\"); } public void destroy() { System.out.println(\"destroy 호출.\"); } protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"service 호출.\"); }} 결과서버 실행 후 클라이언트에서 서블릿 요청시 클라이언트에서 서블릿 요청시 한번 더 요청시 코드 수정 후init() 메소드의 System.out.println(&quot;init test 호출.&quot;) 로 수정했다. 123public void init(ServletConfig config) throws ServletException { System.out.println(\"init test 호출.\");} 다시 요청","link":"/2020/02/28/Booster/life-cycle-servlet/"},{"title":"[부스트코스] request와 response 객체 이해하기","text":"request와 response 객체가 무엇인지와 사용법에 대한 포스팅입니다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. 요청과 응답WAS는 웹브라우저로부터 servlet 요청을 받으면 다음과 같은 작업을 수행한다. 브라우저가 요청할 때 가지고 있는 정보를 HttpServletRequest 객체를 생성하여 저장한다. 웹 브라우저에게 응답을 보내기 위해 HttpServletResponse 객체를 생성한다. 생성된 HttpServletRequest, HttpServletResponse 객체를 servlet에게 전달한다. HttpServletRequest 브라우저가 요청을 할 때 요청 정보들을 servlet에게 전달하기 위해 사용된다. 헤더정보, 파라미터, 쿠키, URI, URL 등의 정보를 저장한다. Body의 Stream을 읽어 들이는 메소드가 존재한다. HttpServletResponse WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여 servlet에게 전달한다. servlet은 HttpServletResponse 객체를 사용하여 content type 설정, 데이터 전송을 한다. HttpServletRequest 객체에 저장된 데이터 출력HttpServletRequest 객체에 저장되어 있는 각종 데이터들을 출력해본다. 123456789101112131415161718192021222324252627282930313233343536373839package examples;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/header\")public class HeaderServlet extends HttpServlet { private static final long serialVersionUID = 1L; public HeaderServlet() { super(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html\"); PrintWriter out = response.getWriter(); out.println(\"&lt;html&gt;\"); out.println(\"&lt;head&gt;&lt;title&gt;form&lt;/title&gt;&lt;/head&gt;\"); out.println(\"&lt;body&gt;\"); Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()) { String headerName = headerNames.nextElement(); String headerValue = request.getHeader(headerName); out.println(headerName + \" : \" + headerValue + \" &lt;br&gt; \"); } out.println(\"&lt;/body&gt;\"); out.println(\"&lt;/html&gt;\"); }} 결과 그 외의 요청정보 출력1234567891011121314151617181920212223242526272829303132333435363738394041package examples;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/info\")public class InfoServlet extends HttpServlet { private static final long serialVersionUID = 1L; public InfoServlet() { super(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html\"); PrintWriter out = response.getWriter(); out.println(\"&lt;html&gt;\"); out.println(\"&lt;head&gt;&lt;title&gt;info&lt;/title&gt;&lt;/head&gt;\"); out.println(\"&lt;body&gt;\"); String uri = request.getRequestURI(); StringBuffer url = request.getRequestURL(); String contentPath = request.getContextPath(); String remoteAddr = request.getRemoteAddr(); out.println(\"uri : \" + uri + \"&lt;br&gt;\"); out.println(\"url : \" + url + \"&lt;br&gt;\"); out.println(\"contentPath : \" + contentPath + \"&lt;br&gt;\"); out.println(\"remoteAddr : \" + remoteAddr + \"&lt;br&gt;\"); out.println(\"&lt;/body&gt;\"); out.println(\"&lt;/html&gt;\"); }} 결과 Get 방식의 파라미터 읽어 들이기123456789101112131415161718192021222324252627282930313233343536package examples;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/param\")public class ParameterServlet extends HttpServlet { private static final long serialVersionUID = 1L; public ParameterServlet() { super(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html;charset=utf-8\"); PrintWriter out = response.getWriter(); out.println(\"&lt;html&gt;\"); out.println(\"&lt;head&gt;&lt;title&gt;form&lt;/title&gt;&lt;/head&gt;\"); out.println(\"&lt;body&gt;\"); String name = request.getParameter(\"name\"); String age = request.getParameter(\"age\"); out.println(\"name : \" + name + \"&lt;br/&gt;\"); out.println(\"age : \" + age + \"&lt;br/&gt;\"); out.println(\"&lt;/body&gt;\"); out.println(\"&lt;/html&gt;\"); }} 파라미터 값이 없을 경우 파라미터 값이 있을 경우","link":"/2020/02/29/Booster/request-response/"},{"title":"백준 2748번 문제","text":".","link":"/2020/03/04/Algorithm/baekjoon-2748/"},{"title":"백준 1003번 문제","text":".","link":"/2020/03/04/Algorithm/baekjoon-1003/"},{"title":"백준 1904번 문제","text":".","link":"/2020/03/04/Algorithm/baekjoon-1904/"},{"title":"백준 1932번 문제","text":".","link":"/2020/03/04/Algorithm/baekjoon-1932/"},{"title":"[부스트코스] Javascript 이벤트","text":"JavaScript로 마우스로 클릭하거나, 화면을 스크롤 하는 등 여러 event를 감지해 원하는 작업을 하도록 하는 방법에 대한 포스팅 입니다. 해당 포스팅은 커넥트재단의 edwith boostcourse - Web Programming의 강의 자료를 바탕으로 작성되었습니다. Event브라우저를 사용하면 많은 이벤트들이 발생한다. 마우스 이벤트, 키보드 이벤트, 폼 이벤트, 문서 이벤트 등 정말 많은 이벤트들이 있다. 이러한 이벤트들이 발생할 때 마다 우리는 특정 이벤트들이 발생할 때 어떠한 일을 하도록 JavaScript를 통해 시킬 수 있습니다. 이벤트 등록이벤트를 등록하려면 addEventListener 함수를 사용하면 된다. 이는 이벤트리스너(Event Listener) 혹은 이벤트핸들러(Event Handler) 라고 불린다. 12345678910&lt;!-- test.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"click\"&gt;클릭하세요.&lt;/div&gt; &lt;/body&gt; &lt;script src='test.js'&gt;&lt;/script&gt;&lt;/html&gt; 12345// test.jsconst el = document.querySelector(\"#click\");el.addEventListener(\"click\", function(){ //do something..}, false); 이벤트 객체123456// test.jsconst el = document.querySelector(\"#click\");el.addEventListener(\"click\", function(evn){ console.log(evn); console.log(evn.target);}, false); 결과 결과를 보면 알겠지만 이벤트 객체에는 정말 많은 정보들이 있다. 마우스 좌표나 키보드가 눌려진 여부 등이 있다. 이러한 속성을 이용할 수도 있다.","link":"/2020/03/05/Booster/javascript-event/"}],"tags":[{"name":"baekjoon","slug":"baekjoon","link":"/tags/baekjoon/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"부스트코스","slug":"부스트코스","link":"/tags/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BD%94%EC%8A%A4/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"browser","slug":"browser","link":"/tags/browser/"},{"name":"booster","slug":"booster","link":"/tags/booster/"},{"name":"protocol","slug":"protocol","link":"/tags/protocol/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"stl","slug":"stl","link":"/tags/stl/"},{"name":"next.js","slug":"next-js","link":"/tags/next-js/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"react.js","slug":"react-js","link":"/tags/react-js/"},{"name":"fetch","slug":"fetch","link":"/tags/fetch/"},{"name":"ajex","slug":"ajex","link":"/tags/ajex/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"rendering","slug":"rendering","link":"/tags/rendering/"},{"name":"was","slug":"was","link":"/tags/was/"},{"name":"servlet","slug":"servlet","link":"/tags/servlet/"},{"name":"jsp","slug":"jsp","link":"/tags/jsp/"},{"name":"request","slug":"request","link":"/tags/request/"},{"name":"response","slug":"response","link":"/tags/response/"},{"name":"Dynamic programming","slug":"Dynamic-programming","link":"/tags/Dynamic-programming/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"event","slug":"event","link":"/tags/event/"}],"categories":[{"name":"Devlog","slug":"Devlog","link":"/categories/Devlog/"},{"name":"Boost Course","slug":"Devlog/Boost-Course","link":"/categories/Devlog/Boost-Course/"},{"name":"Algorithm","slug":"Devlog/Algorithm","link":"/categories/Devlog/Algorithm/"},{"name":"C++","slug":"Devlog/C","link":"/categories/Devlog/C/"},{"name":"Next.js","slug":"Devlog/Next-js","link":"/categories/Devlog/Next-js/"},{"name":"Web","slug":"Devlog/Web","link":"/categories/Devlog/Web/"}]}